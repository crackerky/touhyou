import { create } from 'zustand';\nimport { supabase } from '../lib/supabase';\nimport { isValidEthereumAddress, isCardanoAddressFormatValid, normalizeCardanoAddress } from '../lib/utils';\nimport { isValidCardanoAddress } from '../lib/wallet';\nimport { verifyNFTOwnership, NFTData } from '../lib/nft';\n\ninterface VoteState {\n  wallet: string | null;\n  isVerified: boolean;\n  hasVoted: boolean;\n  isLoading: boolean;\n  error: string | null;\n  votes: Record<string, number>;\n  \n  // NFT関連の新しいステート\n  nftVerificationStatus: 'pending' | 'verified' | 'failed' | null;\n  nftData: NFTData | null;\n  isNFTHolder: boolean;\n  \n  verifyWallet: (address: string, email?: string) => Promise<boolean>;\n  castVote: (option: string) => Promise<boolean>;\n  getVoteCounts: () => Promise<void>;\n  // NFT検証用の新しいメソッド\n  verifyNFTOwnership: (walletAddress: string, email?: string) => Promise<boolean>;\n  reset: () => void;\n}\n\nexport const useVoteStore = create<VoteState>((set, get) => ({\n  wallet: null,\n  isVerified: false,\n  hasVoted: false,\n  isLoading: false,\n  error: null,\n  // 果物の投票オプションに更新（後方互換性も考慮）\n  votes: { \n    'banana': 0, \n    'apple': 0, \n    'orange': 0,\n    // 古いキーも保持（既存データとの互換性のため）\n    'option1': 0, \n    'option2': 0, \n    'option3': 0 \n  },\n  \n  // NFT関連の初期ステート\n  nftVerificationStatus: null,\n  nftData: null,\n  isNFTHolder: false,\n\n  verifyWallet: async (address: string, email?: string) => {\n    try {\n      set({ isLoading: true, error: null });\n      \n      console.log('Verifying wallet address:', address);\n      \n      // First check format with regex (fast)\n      const isValidFormat = isValidEthereumAddress(address) || isCardanoAddressFormatValid(address);\n      \n      if (!isValidFormat) {\n        set({ error: '無効なウォレットアドレス形式です', isLoading: false });\n        return false;\n      }\n\n      // For Cardano addresses, also do a more thorough check if possible\n      if (!isValidEthereumAddress(address)) {\n        try {\n          const isValid = await isValidCardanoAddress(address);\n          if (!isValid) {\n            console.warn('Address failed WASM validation but passed regex check:', address);\n            // We continue anyway since the regex passed, and the WASM lib might not be loaded\n          }\n        } catch (err) {\n          console.error('Cardano address validation error:', err);\n          // Continue since the regex check passed\n        }\n      }\n\n      // アドレスを正規化（必要に応じて）\n      let normalizedAddress = address;\n      try {\n        normalizedAddress = await normalizeCardanoAddress(address);\n        console.log('Normalized address:', normalizedAddress);\n      } catch (err) {\n        console.warn('Address normalization failed, using original:', err);\n        normalizedAddress = address;\n      }\n\n      // 複数の形式のアドレスをチェック（HexとBech32の両方）\n      const addressesToCheck = [normalizedAddress];\n      if (normalizedAddress !== address) {\n        addressesToCheck.push(address);\n      }\n\n      console.log('Checking addresses:', addressesToCheck);\n\n      // ウォレットが存在するか確認（複数のアドレス形式をチェック）\n      const { data: existingWallets, error: fetchError } = await supabase\n        .from('wallets')\n        .select('*')\n        .in('address', addressesToCheck)\n        .order('created_at', { ascending: false }); // 最新のレコードを優先\n\n      if (fetchError) {\n        console.error('Database fetch error:', fetchError);\n        set({ error: `データの取得に失敗しました: ${fetchError.message}`, isLoading: false });\n        return false;\n      }\n\n      // 🎯 NFT検証を実行\n      set({ nftVerificationStatus: 'pending' });\n      const nftVerification = await get().verifyNFTOwnership(normalizedAddress, email);\n      \n      if (!nftVerification) {\n        set({ \n          error: 'NFT保有が確認できませんでした。投票には対象NFTの保有が必要です。',\n          isLoading: false,\n          nftVerificationStatus: 'failed'\n        });\n        return false;\n      }\n\n      // 既存のウォレットが見つかった場合\n      if (existingWallets && existingWallets.length > 0) {\n        const existingWallet = existingWallets[0]; // 最新のレコードを使用\n        console.log('Found existing wallet:', existingWallet);\n        \n        // 重複レコードがある場合は古いものを削除\n        if (existingWallets.length > 1) {\n          console.log('Found duplicate wallets, cleaning up...');\n          const walletsToDelete = existingWallets.slice(1).map(w => w.id);\n          const { error: deleteError } = await supabase\n            .from('wallets')\n            .delete()\n            .in('id', walletsToDelete);\n          \n          if (deleteError) {\n            console.warn('Failed to clean up duplicate wallets:', deleteError);\n          } else {\n            console.log('Cleaned up duplicate wallets');\n          }\n        }\n\n        set({ \n          wallet: normalizedAddress, // 正規化されたアドレスを使用\n          isVerified: true,\n          hasVoted: existingWallet.has_voted,\n          isLoading: false,\n          nftVerificationStatus: 'verified'\n        });\n        return true;\n      }\n\n      // 新しいウォレットレコードを作成\n      console.log('Creating new wallet record for:', normalizedAddress);\n      const { data: newWallet, error: insertError } = await supabase\n        .from('wallets')\n        .insert([{ \n          address: normalizedAddress, \n          has_voted: false,\n          nft_verified: true, // NFT検証済みフラグを追加\n          nft_policy_id: get().nftData?.policyId\n        }])\n        .select()\n        .single();\n\n      if (insertError) {\n        console.error('Wallet insertion error:', insertError);\n        \n        // 重複キーエラーの場合は再度検索を試行\n        if (insertError.code === '23505') {\n          console.log('Duplicate key detected, retrying fetch...');\n          const { data: retryWallets, error: retryError } = await supabase\n            .from('wallets')\n            .select('*')\n            .in('address', addressesToCheck)\n            .order('created_at', { ascending: false })\n            .limit(1);\n\n          if (!retryError && retryWallets && retryWallets.length > 0) {\n            const wallet = retryWallets[0];\n            set({ \n              wallet: normalizedAddress,\n              isVerified: true,\n              hasVoted: wallet.has_voted,\n              isLoading: false,\n              nftVerificationStatus: 'verified'\n            });\n            return true;\n          }\n        }\n        \n        set({ error: `ウォレット登録に失敗しました: ${insertError.message}`, isLoading: false });\n        return false;\n      }\n\n      console.log('Successfully created wallet:', newWallet);\n      set({ \n        wallet: normalizedAddress, \n        isVerified: true,\n        hasVoted: false, \n        isLoading: false,\n        nftVerificationStatus: 'verified'\n      });\n      return true;\n    } catch (error) {\n      console.error('Wallet verification error:', error);\n      const errorMessage = error instanceof Error ? error.message : '不明なエラー';\n      set({ error: `ウォレットの検証に失敗しました: ${errorMessage}`, isLoading: false });\n      return false;\n    }\n  },\n\n  // 🎯 新しいNFT検証メソッド\n  verifyNFTOwnership: async (walletAddress: string, email?: string) => {\n    try {\n      console.log('Starting NFT ownership verification for:', walletAddress);\n      \n      const { hasNFT, nftData, error } = await verifyNFTOwnership(walletAddress, email);\n      \n      if (error) {\n        console.error('NFT verification error:', error);\n        set({ \n          nftVerificationStatus: 'failed',\n          nftData: null,\n          isNFTHolder: false,\n          error: `NFT検証エラー: ${error}`\n        });\n        return false;\n      }\n      \n      if (hasNFT && nftData) {\n        console.log('NFT ownership verified:', nftData);\n        set({ \n          nftVerificationStatus: 'verified',\n          nftData,\n          isNFTHolder: true\n        });\n        return true;\n      } else {\n        console.log('No NFT ownership found');\n        set({ \n          nftVerificationStatus: 'failed',\n          nftData: null,\n          isNFTHolder: false\n        });\n        return false;\n      }\n    } catch (error) {\n      console.error('NFT verification failed:', error);\n      set({ \n        nftVerificationStatus: 'failed',\n        nftData: null,\n        isNFTHolder: false,\n        error: `NFT検証に失敗しました: ${error instanceof Error ? error.message : '不明なエラー'}`\n      });\n      return false;\n    }\n  },\n\n  castVote: async (option: string) => {\n    const { wallet, isNFTHolder } = get();\n    \n    if (!wallet) {\n      set({ error: 'ウォレットが検証されていません' });\n      return false;\n    }\n\n    // 🎯 NFT保有チェックを追加\n    if (!isNFTHolder) {\n      set({ error: 'NFTを保有していないため投票できません' });\n      return false;\n    }\n\n    try {\n      set({ isLoading: true, error: null });\n\n      console.log('Casting vote for wallet:', wallet, 'option:', option);\n\n      // 投票を挿入\n      const { error: voteError } = await supabase\n        .from('votes')\n        .insert([{ \n          wallet_address: wallet, \n          option,\n          nft_verified: true, // NFT検証済みフラグ\n          policy_id: get().nftData?.policyId\n        }]);\n\n      if (voteError) {\n        console.error('Vote insertion error:', voteError);\n        set({ error: `投票登録に失敗しました: ${voteError.message}`, isLoading: false });\n        return false;\n      }\n\n      // ウォレットステータスを更新\n      const { error: updateError } = await supabase\n        .from('wallets')\n        .update({ has_voted: true })\n        .eq('address', wallet);\n\n      if (updateError) {\n        console.error('Wallet update error:', updateError);\n        set({ error: `ウォレット状態の更新に失敗しました: ${updateError.message}`, isLoading: false });\n        return false;\n      }\n\n      // ローカル状態を更新\n      set({ hasVoted: true, isLoading: false });\n      \n      // 投票数を更新\n      await get().getVoteCounts();\n      \n      console.log('Vote cast successfully with NFT verification');\n      return true;\n    } catch (error) {\n      console.error('Vote casting error:', error);\n      const errorMessage = error instanceof Error ? error.message : '不明なエラー';\n      set({ error: `投票に失敗しました: ${errorMessage}`, isLoading: false });\n      return false;\n    }\n  },\n\n  getVoteCounts: async () => {\n    try {\n      set({ isLoading: true });\n      \n      const { data, error } = await supabase\n        .from('votes')\n        .select('option');\n\n      if (error) {\n        console.error('Vote counts fetch error:', error);\n        set({ error: `投票データの取得に失敗しました: ${error.message}`, isLoading: false });\n        return;\n      }\n\n      // 果物の投票カウントを初期化（新旧両方のキーに対応）\n      const voteCounts: Record<string, number> = { \n        'banana': 0, \n        'apple': 0, \n        'orange': 0,\n        'option1': 0, \n        'option2': 0, \n        'option3': 0 \n      };\n      \n      data?.forEach(vote => {\n        if (voteCounts[vote.option] !== undefined) {\n          voteCounts[vote.option]++;\n        }\n      });\n\n      console.log('Updated vote counts:', voteCounts);\n      set({ votes: voteCounts, isLoading: false });\n    } catch (error) {\n      console.error('Get vote counts error:', error);\n      const errorMessage = error instanceof Error ? error.message : '不明なエラー';\n      set({ error: `投票数の取得に失敗しました: ${errorMessage}`, isLoading: false });\n    }\n  },\n\n  reset: () => {\n    console.log('Resetting vote store');\n    set({\n      wallet: null,\n      isVerified: false,\n      hasVoted: false,\n      error: null,\n      // NFT関連のステートもリセット\n      nftVerificationStatus: null,\n      nftData: null,\n      isNFTHolder: false\n    });\n  }\n}));"
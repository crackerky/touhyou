import { create } from 'zustand';\nimport { supabase } from '../lib/supabase';\nimport { isValidEthereumAddress, isCardanoAddressFormatValid, normalizeCardanoAddress } from '../lib/utils';\nimport { isValidCardanoAddress } from '../lib/wallet';\nimport { verifyNFTOwnership, NFTData } from '../lib/nft';\n\ninterface VoteState {\n  wallet: string | null;\n  isVerified: boolean;\n  hasVoted: boolean;\n  isLoading: boolean;\n  error: string | null;\n  votes: Record<string, number>;\n  \n  // NFTé–¢é€£ã®æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ãƒˆ\n  nftVerificationStatus: 'pending' | 'verified' | 'failed' | null;\n  nftData: NFTData | null;\n  isNFTHolder: boolean;\n  \n  verifyWallet: (address: string, email?: string) => Promise<boolean>;\n  castVote: (option: string) => Promise<boolean>;\n  getVoteCounts: () => Promise<void>;\n  // NFTæ¤œè¨¼ç”¨ã®æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰\n  verifyNFTOwnership: (walletAddress: string, email?: string) => Promise<boolean>;\n  reset: () => void;\n}\n\nexport const useVoteStore = create<VoteState>((set, get) => ({\n  wallet: null,\n  isVerified: false,\n  hasVoted: false,\n  isLoading: false,\n  error: null,\n  // æœç‰©ã®æŠ•ç¥¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«æ›´æ–°ï¼ˆå¾Œæ–¹äº’æ›æ€§ã‚‚è€ƒæ…®ï¼‰\n  votes: { \n    'banana': 0, \n    'apple': 0, \n    'orange': 0,\n    // å¤ã„ã‚­ãƒ¼ã‚‚ä¿æŒï¼ˆæ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã¨ã®äº’æ›æ€§ã®ãŸã‚ï¼‰\n    'option1': 0, \n    'option2': 0, \n    'option3': 0 \n  },\n  \n  // NFTé–¢é€£ã®åˆæœŸã‚¹ãƒ†ãƒ¼ãƒˆ\n  nftVerificationStatus: null,\n  nftData: null,\n  isNFTHolder: false,\n\n  verifyWallet: async (address: string, email?: string) => {\n    try {\n      set({ isLoading: true, error: null });\n      \n      console.log('Verifying wallet address:', address);\n      \n      // First check format with regex (fast)\n      const isValidFormat = isValidEthereumAddress(address) || isCardanoAddressFormatValid(address);\n      \n      if (!isValidFormat) {\n        set({ error: 'ç„¡åŠ¹ãªã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹å½¢å¼ã§ã™', isLoading: false });\n        return false;\n      }\n\n      // For Cardano addresses, also do a more thorough check if possible\n      if (!isValidEthereumAddress(address)) {\n        try {\n          const isValid = await isValidCardanoAddress(address);\n          if (!isValid) {\n            console.warn('Address failed WASM validation but passed regex check:', address);\n            // We continue anyway since the regex passed, and the WASM lib might not be loaded\n          }\n        } catch (err) {\n          console.error('Cardano address validation error:', err);\n          // Continue since the regex check passed\n        }\n      }\n\n      // ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ­£è¦åŒ–ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰\n      let normalizedAddress = address;\n      try {\n        normalizedAddress = await normalizeCardanoAddress(address);\n        console.log('Normalized address:', normalizedAddress);\n      } catch (err) {\n        console.warn('Address normalization failed, using original:', err);\n        normalizedAddress = address;\n      }\n\n      // è¤‡æ•°ã®å½¢å¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆHexã¨Bech32ã®ä¸¡æ–¹ï¼‰\n      const addressesToCheck = [normalizedAddress];\n      if (normalizedAddress !== address) {\n        addressesToCheck.push(address);\n      }\n\n      console.log('Checking addresses:', addressesToCheck);\n\n      // ã‚¦ã‚©ãƒ¬ãƒƒãƒˆãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèªï¼ˆè¤‡æ•°ã®ã‚¢ãƒ‰ãƒ¬ã‚¹å½¢å¼ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰\n      const { data: existingWallets, error: fetchError } = await supabase\n        .from('wallets')\n        .select('*')\n        .in('address', addressesToCheck)\n        .order('created_at', { ascending: false }); // æœ€æ–°ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å„ªå…ˆ\n\n      if (fetchError) {\n        console.error('Database fetch error:', fetchError);\n        set({ error: `ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${fetchError.message}`, isLoading: false });\n        return false;\n      }\n\n      // ğŸ¯ NFTæ¤œè¨¼ã‚’å®Ÿè¡Œ\n      set({ nftVerificationStatus: 'pending' });\n      const nftVerification = await get().verifyNFTOwnership(normalizedAddress, email);\n      \n      if (!nftVerification) {\n        set({ \n          error: 'NFTä¿æœ‰ãŒç¢ºèªã§ãã¾ã›ã‚“ã§ã—ãŸã€‚æŠ•ç¥¨ã«ã¯å¯¾è±¡NFTã®ä¿æœ‰ãŒå¿…è¦ã§ã™ã€‚',\n          isLoading: false,\n          nftVerificationStatus: 'failed'\n        });\n        return false;\n      }\n\n      // æ—¢å­˜ã®ã‚¦ã‚©ãƒ¬ãƒƒãƒˆãŒè¦‹ã¤ã‹ã£ãŸå ´åˆ\n      if (existingWallets && existingWallets.length > 0) {\n        const existingWallet = existingWallets[0]; // æœ€æ–°ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨\n        console.log('Found existing wallet:', existingWallet);\n        \n        // é‡è¤‡ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã¯å¤ã„ã‚‚ã®ã‚’å‰Šé™¤\n        if (existingWallets.length > 1) {\n          console.log('Found duplicate wallets, cleaning up...');\n          const walletsToDelete = existingWallets.slice(1).map(w => w.id);\n          const { error: deleteError } = await supabase\n            .from('wallets')\n            .delete()\n            .in('id', walletsToDelete);\n          \n          if (deleteError) {\n            console.warn('Failed to clean up duplicate wallets:', deleteError);\n          } else {\n            console.log('Cleaned up duplicate wallets');\n          }\n        }\n\n        set({ \n          wallet: normalizedAddress, // æ­£è¦åŒ–ã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨\n          isVerified: true,\n          hasVoted: existingWallet.has_voted,\n          isLoading: false,\n          nftVerificationStatus: 'verified'\n        });\n        return true;\n      }\n\n      // æ–°ã—ã„ã‚¦ã‚©ãƒ¬ãƒƒãƒˆãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆ\n      console.log('Creating new wallet record for:', normalizedAddress);\n      const { data: newWallet, error: insertError } = await supabase\n        .from('wallets')\n        .insert([{ \n          address: normalizedAddress, \n          has_voted: false,\n          nft_verified: true, // NFTæ¤œè¨¼æ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’è¿½åŠ \n          nft_policy_id: get().nftData?.policyId\n        }])\n        .select()\n        .single();\n\n      if (insertError) {\n        console.error('Wallet insertion error:', insertError);\n        \n        // é‡è¤‡ã‚­ãƒ¼ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯å†åº¦æ¤œç´¢ã‚’è©¦è¡Œ\n        if (insertError.code === '23505') {\n          console.log('Duplicate key detected, retrying fetch...');\n          const { data: retryWallets, error: retryError } = await supabase\n            .from('wallets')\n            .select('*')\n            .in('address', addressesToCheck)\n            .order('created_at', { ascending: false })\n            .limit(1);\n\n          if (!retryError && retryWallets && retryWallets.length > 0) {\n            const wallet = retryWallets[0];\n            set({ \n              wallet: normalizedAddress,\n              isVerified: true,\n              hasVoted: wallet.has_voted,\n              isLoading: false,\n              nftVerificationStatus: 'verified'\n            });\n            return true;\n          }\n        }\n        \n        set({ error: `ã‚¦ã‚©ãƒ¬ãƒƒãƒˆç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ: ${insertError.message}`, isLoading: false });\n        return false;\n      }\n\n      console.log('Successfully created wallet:', newWallet);\n      set({ \n        wallet: normalizedAddress, \n        isVerified: true,\n        hasVoted: false, \n        isLoading: false,\n        nftVerificationStatus: 'verified'\n      });\n      return true;\n    } catch (error) {\n      console.error('Wallet verification error:', error);\n      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';\n      set({ error: `ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã®æ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMessage}`, isLoading: false });\n      return false;\n    }\n  },\n\n  // ğŸ¯ æ–°ã—ã„NFTæ¤œè¨¼ãƒ¡ã‚½ãƒƒãƒ‰\n  verifyNFTOwnership: async (walletAddress: string, email?: string) => {\n    try {\n      console.log('Starting NFT ownership verification for:', walletAddress);\n      \n      const { hasNFT, nftData, error } = await verifyNFTOwnership(walletAddress, email);\n      \n      if (error) {\n        console.error('NFT verification error:', error);\n        set({ \n          nftVerificationStatus: 'failed',\n          nftData: null,\n          isNFTHolder: false,\n          error: `NFTæ¤œè¨¼ã‚¨ãƒ©ãƒ¼: ${error}`\n        });\n        return false;\n      }\n      \n      if (hasNFT && nftData) {\n        console.log('NFT ownership verified:', nftData);\n        set({ \n          nftVerificationStatus: 'verified',\n          nftData,\n          isNFTHolder: true\n        });\n        return true;\n      } else {\n        console.log('No NFT ownership found');\n        set({ \n          nftVerificationStatus: 'failed',\n          nftData: null,\n          isNFTHolder: false\n        });\n        return false;\n      }\n    } catch (error) {\n      console.error('NFT verification failed:', error);\n      set({ \n        nftVerificationStatus: 'failed',\n        nftData: null,\n        isNFTHolder: false,\n        error: `NFTæ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'}`\n      });\n      return false;\n    }\n  },\n\n  castVote: async (option: string) => {\n    const { wallet, isNFTHolder } = get();\n    \n    if (!wallet) {\n      set({ error: 'ã‚¦ã‚©ãƒ¬ãƒƒãƒˆãŒæ¤œè¨¼ã•ã‚Œã¦ã„ã¾ã›ã‚“' });\n      return false;\n    }\n\n    // ğŸ¯ NFTä¿æœ‰ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ \n    if (!isNFTHolder) {\n      set({ error: 'NFTã‚’ä¿æœ‰ã—ã¦ã„ãªã„ãŸã‚æŠ•ç¥¨ã§ãã¾ã›ã‚“' });\n      return false;\n    }\n\n    try {\n      set({ isLoading: true, error: null });\n\n      console.log('Casting vote for wallet:', wallet, 'option:', option);\n\n      // æŠ•ç¥¨ã‚’æŒ¿å…¥\n      const { error: voteError } = await supabase\n        .from('votes')\n        .insert([{ \n          wallet_address: wallet, \n          option,\n          nft_verified: true, // NFTæ¤œè¨¼æ¸ˆã¿ãƒ•ãƒ©ã‚°\n          policy_id: get().nftData?.policyId\n        }]);\n\n      if (voteError) {\n        console.error('Vote insertion error:', voteError);\n        set({ error: `æŠ•ç¥¨ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ: ${voteError.message}`, isLoading: false });\n        return false;\n      }\n\n      // ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°\n      const { error: updateError } = await supabase\n        .from('wallets')\n        .update({ has_voted: true })\n        .eq('address', wallet);\n\n      if (updateError) {\n        console.error('Wallet update error:', updateError);\n        set({ error: `ã‚¦ã‚©ãƒ¬ãƒƒãƒˆçŠ¶æ…‹ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${updateError.message}`, isLoading: false });\n        return false;\n      }\n\n      // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚’æ›´æ–°\n      set({ hasVoted: true, isLoading: false });\n      \n      // æŠ•ç¥¨æ•°ã‚’æ›´æ–°\n      await get().getVoteCounts();\n      \n      console.log('Vote cast successfully with NFT verification');\n      return true;\n    } catch (error) {\n      console.error('Vote casting error:', error);\n      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';\n      set({ error: `æŠ•ç¥¨ã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMessage}`, isLoading: false });\n      return false;\n    }\n  },\n\n  getVoteCounts: async () => {\n    try {\n      set({ isLoading: true });\n      \n      const { data, error } = await supabase\n        .from('votes')\n        .select('option');\n\n      if (error) {\n        console.error('Vote counts fetch error:', error);\n        set({ error: `æŠ•ç¥¨ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, isLoading: false });\n        return;\n      }\n\n      // æœç‰©ã®æŠ•ç¥¨ã‚«ã‚¦ãƒ³ãƒˆã‚’åˆæœŸåŒ–ï¼ˆæ–°æ—§ä¸¡æ–¹ã®ã‚­ãƒ¼ã«å¯¾å¿œï¼‰\n      const voteCounts: Record<string, number> = { \n        'banana': 0, \n        'apple': 0, \n        'orange': 0,\n        'option1': 0, \n        'option2': 0, \n        'option3': 0 \n      };\n      \n      data?.forEach(vote => {\n        if (voteCounts[vote.option] !== undefined) {\n          voteCounts[vote.option]++;\n        }\n      });\n\n      console.log('Updated vote counts:', voteCounts);\n      set({ votes: voteCounts, isLoading: false });\n    } catch (error) {\n      console.error('Get vote counts error:', error);\n      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';\n      set({ error: `æŠ•ç¥¨æ•°ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMessage}`, isLoading: false });\n    }\n  },\n\n  reset: () => {\n    console.log('Resetting vote store');\n    set({\n      wallet: null,\n      isVerified: false,\n      hasVoted: false,\n      error: null,\n      // NFTé–¢é€£ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚‚ãƒªã‚»ãƒƒãƒˆ\n      nftVerificationStatus: null,\n      nftData: null,\n      isNFTHolder: false\n    });\n  }\n}));"